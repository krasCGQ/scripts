# shellcheck shell=bash
# Environment setup for my notebook
# Copyright (C) 2017-2019 Albert I (krasCGQ)
# SPDX-License-Identifier: GPL-3.0-or-later

# Don't setup if not in correct environment
[[ $(hostname) = harutsuki || $(hostname) = strelka ]] || return 1

# Set path to script directory depending on which shell we use
if [[ -n $BASH ]]; then
    # Bash
    SCRIPTDIR=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")/..
elif [[ -n $ZSH_VERSION ]]; then
    # Zsh
    # shellcheck disable=SC2154
    SCRIPTDIR=$(dirname ${(%):-%x})/..
else
    echo "! Unsupported shell. Exiting." >&2
    return 1
fi

# Import common environment script
# shellcheck source=/dev/null
source "$SCRIPTDIR"/env/common

# Aliases
alias ak-build='$SCRIPTDIR/tasks/kernel.bash'
alias neofetch='neofetch --os_arch off --speed_shorthand on --cpu_temp C --cpu_cores off --uptime_shorthand tiny --gtk_shorthand on --color_blocks off'
alias reflector='sudo reflector --save /etc/pacman.d/mirrorlist --sort rate --threads 8 --ipv4'
alias sys2sbin='sed -i "s|/system/bin/linker64|/sbin/linker64\x0\x0\x0\x0\x0\x0|g"'
alias update='sudo su -c "pacman -Sy && powerpill -Su --noconfirm"'
alias update-grub='sudo grub-mkconfig -o /boot/grub/grub.cfg'

# Export new PATH containing local binaries
[[ -z $TMUX ]] && export PATH=$HOME/.files/bin:$PATH

# (Re)Pack FLAC files with maximum compression and ReplayGain applied
flac_pack() {
    # Mark functions as local
    local BASE_NAME LIST OLD_LIST REPACK SONG

    # Make sure FLAC package is installed
    [[ -z $(command -v flac) ]] && { warn "Please install flac package before continuing."; return 1; }

    # Parse parameters
    while [[ $# -ge 1 ]]; do
        case $1 in
            # Request repacking of existing FLAC files
            -r |--repack)
                REPACK=true ;;

            # Embed ReplayGain information of all songs in a single folder
            -rg|--replay-gain)
                REPLAY_GAIN=true ;;

            # Unrecognized parameter, skip
            *)
                warn "Unrecognized parameter specified: \"$1\"" ;;
        esac
        shift
    done

    # If repack requested
    if [[ -n $REPACK ]]; then
        # List FLAC files to repack
        for SONG in ./*.flac; do
            LIST+=( "$(basename "$SONG")" )
        done

        # Exit function if nothing to repack
        [[ -z ${LIST[*]} || ${LIST[*]} = "*.flac" ]] && { warn "Repack requested, but there's nothing to do."; return 1; }

        # Unpack FLAC files
        for SONG in "${LIST[@]}"; do
            info "Unpacking \"$SONG\"..."
            flac --delete-input-file --totally-silent -d "$SONG" || { warn "Failed to unpack \"$SONG\"."; return 1; }
        done
    fi

    # If repack requested
    if [[ -n ${LIST[*]} ]]; then
        # Move LIST arrays to OLD_LIST and unset the variable
        OLD_LIST=( "${LIST[@]}" )
        unset LIST

        # Based on values OLD_LIST array, we set values for PCM files
        for SONG in "${OLD_LIST[@]}"; do
            BASE_NAME="$(basename "$SONG" | sed -e s/.flac//)"
            for FORMAT in aiff wav; do
                if [[ -f $BASE_NAME.$FORMAT ]]; then
                    LIST+=( "$BASE_NAME.$FORMAT" )
                    break
                fi
            done
        done
    # Else, list all supported PCM audio files
    else
        for SONG in ./*; do
            BASE_NAME="$(basename "$SONG")"
            case "$BASE_NAME" in
                # AIFF/WAV PCM file
                *.aiff|*.wav)
                    LIST+=( "$BASE_NAME" ) ;;

                # FLAC file, already packed
                *.flac)
                    warn "Skipping already packed audio file: $BASE_NAME" ;;

                # Unsupported audio/file format
                *)
                    [[ $BASE_NAME != "*" ]] && warn "Skipping unsupported file/audio format: $BASE_NAME" ;;
            esac
        done
    fi

    # Exit function if nothing to pack
    [[ -z ${LIST[*]} ]] && { warn "There's nothing to do."; return 1; }

    # Pack PCM audio files with maximum compression
    for SONG in "${LIST[@]}"; do
        info "Packing \"$SONG\"..."
        flac --delete-input-file --totally-silent -V8 "$SONG" || { warn "Failed to pack \"$SONG\"."; return 1; }
    done

    # Embed ReplayGain if requested
    if [[ -n $REPLAY_GAIN ]]; then
        # Just to make sure that no ReplayGain metadata exist
        metaflac --remove-replay-gain ./*.flac
        # Apply (new) ReplayGain metadata to all songs in same folder
        metaflac --add-replay-gain ./*.flac
    fi

    info "The operation completed successfully."
}

# Convert all FLAC, WAV, and/or AIFF files to Opus
opus_convert() {
    # Ask to install opus-tools package if opusenc doesn't exist
    [[ -z $(command -v opusenc) ]] && { warn "Please install opus-tools package before continuing."; return 1; }

    for SONG in ./*; do
        case "$SONG" in
            *.aiff|*.flac|*.wav)
                # Declare that we have something to do!
                SUPPORTED=true

                # Not supporting wildcards for converting
                opusenc --quiet --vbr --bitrate 192 --comp 10 --expect-loss 0 \
                    "$SONG" "$(basename "$SONG" | sed 's/\(.*\)\..*/\1/').ogg" || return 1 ;;
        esac
    done

    # Return non-zero status if nothing to do
    [[ -z $SUPPORTED ]] && { warn "There's nothing to do."; return 1; }
}

# Setup environment for AOSP building
function aosp_init { (
    [[ $(whoami) != root ]] && return 1

    local PROJECT_DIR SRC_KERNEL_DIR AOSP_DIR DEST_KERNEL_DIR
    PROJECT_DIR=$USER_DIR/KudProject
    SRC_KERNEL_DIR=$PROJECT_DIR/kernels
    AOSP_DIR=/mnt/android
    DEST_KERNEL_DIR=$AOSP_DIR/xenonhd-p/kernel

    # zRAM setup
    modprobe zram
    echo lz4hc > /sys/devices/virtual/block/zram0/comp_algorithm
    echo 8G > /sys/devices/virtual/block/zram0/disksize
    mkswap /dev/zram0
    swapon --priority 100 /dev/zram0

    # AOSP sparse image setup
    mount -o nosuid,nodev,compress=zstd "$PROJECT_DIR"/android.img $AOSP_DIR
    mount -B "$SRC_KERNEL_DIR"/X00T $DEST_KERNEL_DIR/asus/sdm660
    mount -B "$SRC_KERNEL_DIR"/grus $DEST_KERNEL_DIR/xiaomi/sdm710
    mount -B "$SRC_KERNEL_DIR"/mido $DEST_KERNEL_DIR/xiaomi/msm8953-3.18
) || return 1; }
alias aosp_init='check_sudo --preserve-env=USER_DIR su -c "$(declare -f aosp_init) && aosp_init &> /dev/null"'

# De-init AOSP environment set before
aosp_deinit() {(
    [[ $(whoami) != root ]] && return 1

    if ! umount -R /mnt/android; then
        (
            cd /mnt/android/xenonhd-p/kernel || ROOT_DIR=/mnt/android/xenonhd-p/kernel/
            umount ${ROOT_DIR}asus/sdm660
            umount ${ROOT_DIR}xiaomi/msm8953-3.18
            umount ${ROOT_DIR}xiaomi/sdm710
        )
        umount /mnt/android || umount -l /mnt/android
    fi

    swapoff /dev/zram0
    rmmod /dev/zram0
) || return 0; } # suppress non-zero exit status
alias aosp_deinit='check_sudo su -c "$(declare -f aosp_deinit) && aosp_deinit 2> /dev/null"'

# Quick way to install linux-vk packages
_vk_install() {
    [[ $(whoami) != root ]] && return 1

    local COMMON_DIR PKG_DIR VK_DIR

    COMMON_DIR=$USER_DIR/KudProject/aur
    PKG_DIR=$COMMON_DIR/.packages
    VK_DIR=$COMMON_DIR/linux-vk

    mount -B {"$SCRIPTDIR"/binds,/usr/bin}/gcc
    pacman -U "$PKG_DIR"/linux-vk*"$1"-"$(uname -m)".pkg.tar*
    "$VK_DIR"/sign_modules.sh
    umount /usr/bin/gcc 2> /dev/null
}
vk_install() { check_sudo --preserve-env=SCRIPTDIR,USER_DIR su -c "$(declare -f _vk_install) && _vk_install $1"; }

# Last, but my most convenient part; only apply with Bash
[[ -n $BASH ]] && export PS1='\[\e[1;36m\]\W\[\e[1;34m\]$(parse_git_branch)\[\e[0m\] âŒª'
