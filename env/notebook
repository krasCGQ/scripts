#!/usr/bin/env bash
# Environment setup for my notebook
# Copyright (C) 2017-2018 Albert I (krasCGQ)
# SPDX-License-Identifier: GPL-3.0-or-later

# Don't setup if not in correct environment
[[ $(whoami) != krascgq || $(hostname) != KudNotebook ]] && return 1

# Import common environment script
# shellcheck source=/dev/null
. "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"/common

# Set up aliases
alias neofetch='neofetch --package_managers off --os_arch off --speed_shorthand on --cpu_temp C --cpu_cores off --uptime_shorthand tiny --gtk_shorthand on --color_blocks off'
alias update='sudo su -c "pacman -Sy && powerpill -Su --noconfirm"'

# Export local binary path
export PATH=${HOME}/.files/bin:${PATH}

# Export ccache-backed compiler symlinks
export PATH=/usr/lib/ccache/bin:${PATH}

# Repack FLAC files with maximum compression and ReplayGain applied
function flac_repack {
    # Make sure FLAC package is installed
    [[ -z $(command -v flac) ]] && \
        { warn "Please install flac package before continuing."; return 1; }

    # Make sure we have FLAC files to repack
    [[ $(find . -name "*.flac" | wc -l) -eq 0 ]] && \
        { warn "There's nothing to do."; return 1; }

    # First we decompress
    flac --delete-input-file --totally-silent -d ./*.flac || \
        { warn "Failed to decompress one or more songs."; return 1; }

    # Then we repack with maximum compression and ReplayGain applied
    for SONG in ./*; do
        case "${SONG}" in
            *.aiff|*.wav)
                flac --delete-input-file --totally-silent --replay-gain -V8 "${SONG}" || \
                    { warn "Failed to compress ${SONG}."; return 1; } ;;
        esac
    done
}

# Convert all FLAC, WAV, and/or AIFF files to Opus
function opus_convert {
    # Ask to install opus-tools package if opusenc doesn't exist
    [[ -z $(command -v opusenc) ]] && \
        { warn "Please install opus-tools package before continuing."; return 1; }

    for SONG in ./*; do
        case "${SONG}" in
            *.aiff|*.flac|*.wav)
                # Declare that we have something to do!
                SUPPORTED=true

                # Not supporting wildcards for converting
                opusenc --quiet --vbr --bitrate 192 --comp 10 --expect-loss 0 \
                    "${SONG}" \
                    "$(basename "${SONG}" | sed 's/\(.*\)\..*/\1/').ogg" || \
                    return 1 ;;
        esac
    done

    [[ -z ${SUPPORTED} ]] && \
        { warn "There's nothing to do."; return 1; }
}

# Wrapper to build both AArch64 and x86_64 GNU toolchains using build-tools-gcc
function btg_build {
    [[ -z ${BTGDIR} || -z ${OPTDIR} ]] && \
        { warn "${BLD}BTGDIR${RST} and/or ${BLD}OPTDIR${RST} variables are empty. Refusing to continue."; return 1; }

    (
        cd "${BTGDIR}" || return 1

        # FIXME: Command requires sudo :/
        [[ ! -d ${OPTDIR} ]] && \
            sudo su -c "mkdir -p ${OPTDIR} && chown -R $(whoami):users ${OPTDIR}"

        ./build -a arm -s gnu -v 9 -nt || return 1

        rm -rf "${OPTDIR}"/arm-linux-gnueabi-old
        [[ -d ${OPTDIR}/arm-linux-gnueabi ]] && \
            mv -f "${OPTDIR}"/arm-linux-gnueabi{,-old}
        mv -f arm-linux-gnueabi "${OPTDIR}"

        ./build -a arm64 -s gnu -v 9 -nt -nu || return 1

        rm -rf "${OPTDIR}"/aarch64-linux-gnu-old
        [[ -d ${OPTDIR}/aarch64-linux-gnu ]] && \
            mv -f "${OPTDIR}"/aarch64-linux-gnu{,-old}
        mv -f aarch64-linux-gnu "${OPTDIR}"

        ./build -a x86_64 -s gnu -v 9 -nt -nu || return 1

        rm -rf "${OPTDIR}"/x86_64-linux-gnu-old
        [[ -d ${OPTDIR}/x86_64-linux-gnu ]] && \
            mv -f "${OPTDIR}"/x86_64-linux-gnu{,-old}
        mv -f x86_64-linux-gnu "${OPTDIR}"

        rm -rf build-*
    )
}

# Create an 8 GB swap file
# TODO: File system checks; Btrfs doesn't go well with swap file
function swapfile_create {
    # Local variables
    local FILE_TYPE FILE_SIZE

    # Skip file format and size checks if swap file (?) doesn't exist
    [[ ! -f ${SWAP_FILE} ]] && \
        SWAP_FILE_EXIST=false

    # Declare these to avoid unnecessarily long commands
    [[ -z ${SWAP_FILE_EXIST} ]] && \
        { FILE_TYPE="$(file -b ${SWAP_FILE} | awk '{print $2}')";
          FILE_SIZE="$(ls -s --block-size=G ${SWAP_FILE} | awk '{print $1}')"; }

    # If swap file is exist, technically nothing to do
    [[ ${FILE_TYPE} == swap && ${FILE_SIZE} == 8G ]] && \
        { info "Swap file is exist, no need to re-create it."; return; }

    # TODO: Run with sudo if swap file isn't @ /home or has incorrect permission
    info "Creating swap file. This may take a while..."

    # Write zeros to create a dummy file - 2,048,000 chunks of 4 kilobytes
    dd if=/dev/zero of=${SWAP_FILE} bs=4K count=2048000 2> /dev/null

    # Make sure zeros are written properly
    sync

    # Set dummy file's permission to 0600
    chmod 600 ${SWAP_FILE}

    # Create swap file over dummy file
    mkswap ${SWAP_FILE} > /dev/null

    # (Re-)Assigning for final checks
    FILE_TYPE="$(file -b ${SWAP_FILE} | awk '{print $2}')"
    FILE_SIZE="$(ls -s --block-size=G ${SWAP_FILE} | awk '{print $1}')"

    # Check if swap file is successfully created
    if [[ ${FILE_TYPE} == swap && ${FILE_SIZE} == 8G ]]; then
        info "Operation has completed successfully."
    else
        warn "Failed to do the operation."
        return 1
    fi
}

# Last, but my most convenient part
export PS1='\[\e[1;36m\]\u@\h\[\e[1;37m\] \W\[\e[1;34m\]$(parse_git_branch)\[\e[1;36m\] \$\[\e[0m\] '
