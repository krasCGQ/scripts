#!/usr/bin/env bash
# Environment setup for my notebook
# Copyright (C) 2017-2018 Albert I (krasCGQ)
# SPDX-License-Identifier: GPL-3.0-or-later

# Don't setup if not in correct environment
[[ $(whoami) != krascgq || $(hostname) != KudNotebook ]] && return 1

# Import common environment script
# shellcheck source=/dev/null
. "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"/common

# Set up aliases
alias neofetch='neofetch --package_managers off --os_arch off --speed_shorthand on --cpu_temp C --cpu_cores off --uptime_shorthand tiny --gtk_shorthand on --color_blocks off'
alias update='sudo su -c "pacman -Sy && powerpill -Su --noconfirm"'

# Export local binary path
export PATH=${HOME}/.files/bin:${PATH}

# Export ccache-backed compiler symlinks
export PATH=/usr/lib/ccache/bin:${PATH}

# (Re)Pack FLAC files with maximum compression and ReplayGain applied
function flac_pack {
    # Mark functions as local
    local BASE_NAME LIST OLD_LIST REPACK SONG

    # Make sure FLAC package is installed
    [[ -z $(command -v flac) ]] && \
        { warn "Please install flac package before continuing."; return 1; }

    # Parse parameters
    while [[ ${#} -ge 1 ]]; do
        case ${1} in
            # Request repacking of existing FLAC files
            -r|--repack)
                REPACK=true ;;

            # Unrecognized parameter, skip
            *)
                warn "Unrecognized parameter specified: \"${1}\"" ;;
        esac
        shift
    done

    # If repack requested
    if [[ -n ${REPACK} ]]; then
        # List FLAC files to repack
        for SONG in ./*.flac; do
            LIST+=( "$(basename "${SONG}")" )
        done

        # Exit function if nothing to repack
        [[ -z ${LIST[*]} || ${LIST[*]} == *.flac ]] && \
            { warn "Repack requested, but there's nothing to do."; return 1; }

        # Unpack FLAC files
        for SONG in "${LIST[@]}"; do
            info "Unpacking \"${SONG}\"..."
            flac --delete-input-file --totally-silent -d "${SONG}" || \
                { warn "Failed to unpack \"${SONG}\"."; return 1; }
        done
    fi

    # If repack requested
    if [[ -n ${LIST[*]} ]]; then
        # Move LIST arrays to OLD_LIST and unset the variable
        OLD_LIST=( "${LIST[@]}" )
        unset LIST

        # Based on values OLD_LIST array, we set values for PCM files
        for SONG in "${OLD_LIST[@]}"; do
            BASE_NAME="$(basename "${SONG}" | sed -e s/.flac//)"
            for FORMAT in aiff wav; do
                if [[ -f ${BASE_NAME}.${FORMAT} ]]; then
                    LIST+=( "${BASE_NAME}.${FORMAT}" )
                    break
                fi
            done
        done

    # Else, list all supported PCM audio files
    else
        for SONG in ./*; do
            BASE_NAME="$(basename "${SONG}")"
            case "${BASE_NAME}" in
                # AIFF/WAV PCM file
                *.aiff|*.wav)
                    LIST+=( "${BASE_NAME}" ) ;;

                # FLAC file, already packed
                *.flac)
                    warn "Skipping already packed audio file: ${BASE_NAME}" ;;

                # Unsupported audio/file format
                *)
                    [[ ${BASE_NAME} != * ]] && \
                        warn "Skipping unsupported file/audio format: ${BASE_NAME}" ;;
            esac
        done
    fi

    # Exit function if nothing to pack
    [[ -z ${LIST[*]} ]] && \
        { warn "There's nothing to do."; return 1; }

    # Pack PCM audio files with maximum compression and ReplayGain applied
    for SONG in "${LIST[@]}"; do
        info "Packing \"${SONG}\"..."
        flac --delete-input-file --totally-silent --replay-gain -V8 "${SONG}" || \
            { warn "Failed to pack \"${SONG}\"."; return 1; }
    done

    info "The operation completed successfully."
}

# Convert all FLAC, WAV, and/or AIFF files to Opus
function opus_convert {
    # Ask to install opus-tools package if opusenc doesn't exist
    [[ -z $(command -v opusenc) ]] && \
        { warn "Please install opus-tools package before continuing."; return 1; }

    for SONG in ./*; do
        case "${SONG}" in
            *.aiff|*.flac|*.wav)
                # Declare that we have something to do!
                SUPPORTED=true

                # Not supporting wildcards for converting
                opusenc --quiet --vbr --bitrate 192 --comp 10 --expect-loss 0 \
                    "${SONG}" \
                    "$(basename "${SONG}" | sed 's/\(.*\)\..*/\1/').ogg" || \
                    return 1 ;;
        esac
    done

    [[ -z ${SUPPORTED} ]] && \
        { warn "There's nothing to do."; return 1; }
}

# Wrapper to build both AArch64 and x86_64 GNU toolchains using build-tools-gcc
function btg_build {
    [[ -z ${BTGDIR} || -z ${OPTDIR} ]] && \
        { warn "${BLD}BTGDIR${RST} and/or ${BLD}OPTDIR${RST} variables are empty. Refusing to continue."; return 1; }

    (
        cd "${BTGDIR}" || return 1

        # FIXME: Command requires sudo :/
        [[ ! -d ${OPTDIR} ]] && \
            sudo su -c "mkdir -p ${OPTDIR} && chown -R $(whoami):users ${OPTDIR}"

        ./build -a arm -s gnu -v 9 -nt || return 1

        rm -rf "${OPTDIR}"/arm-linux-gnueabi-old
        [[ -d ${OPTDIR}/arm-linux-gnueabi ]] && \
            mv -f "${OPTDIR}"/arm-linux-gnueabi{,-old}
        mv -f arm-linux-gnueabi "${OPTDIR}"

        ./build -a arm64 -s gnu -v 9 -nt -nu || return 1

        rm -rf "${OPTDIR}"/aarch64-linux-gnu-old
        [[ -d ${OPTDIR}/aarch64-linux-gnu ]] && \
            mv -f "${OPTDIR}"/aarch64-linux-gnu{,-old}
        mv -f aarch64-linux-gnu "${OPTDIR}"

        ./build -a x86_64 -s gnu -v 9 -nt -nu || return 1

        rm -rf "${OPTDIR}"/x86_64-linux-gnu-old
        [[ -d ${OPTDIR}/x86_64-linux-gnu ]] && \
            mv -f "${OPTDIR}"/x86_64-linux-gnu{,-old}
        mv -f x86_64-linux-gnu "${OPTDIR}"

        rm -rf build-*
    )
}

# Rebuild DKMS modules of currently installed kernel with Clang (requires sudo)
function dkms_rebuild {
    # Local variables
    local BIND_DIR DKMS_MODULE KERNEL

    # Location of wrappers
    BIND_DIR=${SCRIPTDIR}/binds

    # Current kernel running on system
    KERNEL=$(uname -r)

    # Make sure user has sudo
    info "Checking for sudo; please enter password if prompted."
    ! sudo -v 2> /dev/null && \
        { warn "Current user isn't a sudo!"; return 1; }

    # Make sure session is running kernel that exists in /usr/lib/modules
    [[ ! -d /usr/lib/modules/${KERNEL} ]] && \
        { warn "Current kernel doesn't exist in /usr/lib/modules." \
               "Do you recently updated the kernel and need to reboot?"; return 1; }

    # Bind mount gcc and g++ Clang wrappers to /usr/bin
    { sudo mount --bind "${BIND_DIR}"/gcc /usr/bin/gcc;
      sudo mount --bind "${BIND_DIR}"/g++ /usr/bin/g++; } || return 1

    # List DKMS modules that we're going to reinstall
    for DKMS_MODULE in $(dkms status | grep "${KERNEL}" | cut -d "," -f 1,2 | sed -e 's|, |/|g'); do
        # Reinstall DKMS module
        info "Reinstalling DKMS module: ${DKMS_MODULE}"
        { sudo dkms uninstall "${DKMS_MODULE}" -k "${KERNEL}";
          sudo dkms install "${DKMS_MODULE}" -k "${KERNEL}"; } > /dev/null || return 1
    done

    # Umount wrappers
    { sudo umount /usr/bin/gcc;
      sudo umount /usr/bin/g++; } || return 1

    # Function ends...
    info "The operation completed successfully. Please reboot or modprobe manually."
}

# Create an 8 GB swap file
# TODO: File system checks; Btrfs doesn't go well with swap file
function swapfile_create {
    # Local variables
    local FILE_TYPE FILE_SIZE_MATCH SWAP_FILE_EXIST

    # Skip file format and size checks if swap file (?) doesn't exist
    [[ ! -f ${SWAP_FILE} ]] && \
        SWAP_FILE_EXIST=false

    # Declare these to avoid unnecessarily long commands
    [[ -z ${SWAP_FILE_EXIST} ]] && \
        { FILE_TYPE="$(file -b "${SWAP_FILE}" | awk '{print $2}')";
          FILE_SIZE_MATCH="$(find "${SWAP_FILE}" -size 8G > /dev/null && echo true)"; }

    # If swap file is exist, technically nothing to do
    [[ ${FILE_TYPE} == swap && -n ${FILE_SIZE_MATCH} ]] && \
        { info "Swap file is exist, no need to re-create it."; return; }

    # TODO: Run with sudo if swap file isn't @ /home or has incorrect permission
    info "Creating swap file. This may take a while..."

    # Write zeros to create a dummy file - 2,048,000 chunks of 4 kilobytes
    dd if=/dev/zero of="${SWAP_FILE}" bs=4K count=2048000 2> /dev/null

    # Make sure zeros are written properly
    sync

    # Set dummy file's permission to 0600
    chmod 600 "${SWAP_FILE}"

    # Create swap file over dummy file
    mkswap "${SWAP_FILE}" > /dev/null

    # (Re-)Assigning for final checks
    FILE_TYPE="$(file -b "${SWAP_FILE}" | awk '{print $2}')"
    FILE_SIZE_MATCH="$(find "${SWAP_FILE}" -size 8G > /dev/null && echo true)"

    # Check if swap file is successfully created
    if [[ ${FILE_TYPE} == swap && -n ${FILE_SIZE_MATCH} ]]; then
        info "Operation has completed successfully."
    else
        warn "Failed to do the operation."
        return 1
    fi
}

# Last, but my most convenient part
export PS1='\[\e[1;36m\]\u@\h\[\e[1;37m\] \W\[\e[1;34m\]$(parse_git_branch)\[\e[1;36m\] \$\[\e[0m\] '
