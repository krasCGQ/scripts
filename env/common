# shellcheck shell=bash
# shellcheck source=/dev/null
# Common environment setup
# Copyright (C) 2017-2020 Albert I (krasCGQ)
# SPDX-License-Identifier: GPL-3.0-or-later

# Import treewide environment script
source "$SCRIPT_DIR"/env/global

# Aliases
alias nano='nano -au'
alias wget='wget -c -t 0 --retry-connrefused'

# Required for GPG signing
GPG_TTY=$(tty)
# My kernel identity in nutshell
KBUILD_BUILD_USER=krasCGQ
KBUILD_BUILD_HOST=KudProject
# Export variables to satisfy shellcheck requirements
export GPG_TTY KBUILD_BUILD_USER KBUILD_BUILD_HOST

if [[ -z $IS_TERMUX ]]; then
    # Export HOME as USER_DIR for use with sudo commands when required
    USER_DIR=$HOME
    # GNU nano for text editor
    EDITOR=nano
    # Export variables to satisfy shellcheck requirements
    export USER_DIR EDITOR
fi

# Source Telegram-specific script if exists
[[ -f $SCRIPT_DIR/env/telegram ]] && source "$SCRIPT_DIR"/env/telegram

# Wrapper to automatically merge latest Linux stable revision to working branch
# Usage: korg_merge <revision-to-merge>
korgMerge() { git pull git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux v"$1" --signoff; }

# Bash: Parse current branch in git repository
if [[ -n $BASH ]]; then
    parseGitBranch() {
        local BRANCH
        BRANCH=$(git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/^* //')

        if [[ -n $BRANCH ]]; then
            # Don't give extra brackets if project isn't at any branch or is currently detached
            [[ $BRANCH != "("*")" ]] && BRANCH="($BRANCH)"

            # This is what we want to stdout
            echo " $BRANCH"
        fi
    }
fi

# Get latest Proton clang from GitHub releases
getProtonClang() {
    chkArch x86_64 || return 1
    local INSTALL_DIR LATEST NAME REPO URL VERSION
    INSTALL_DIR=/opt/kud/proton-clang
    REPO=kdrag0n/proton-clang

    prInfo "Obtaining latest version info..."
    LATEST=$(curl -s https://api.github.com/repos/$REPO/releases/latest | grep -w tag_name | cut -d ':' -f 2 | sed -e 's/[[:space:]]//' -e 's/"//g' -e 's/,//')
    if [[ $(<$INSTALL_DIR/ClangVersion.txt 2>/dev/null) -eq $LATEST ]]; then
        # we're up to date, skip.
        prInfo "Clang build $LATEST is up to date."
        rm /tmp/latest.json
        return
    fi

    URL=https://github.com/$REPO/archive/$LATEST.tar.gz
    NAME=$(echo $REPO | cut -d "/" -f 2)-$LATEST.tar.gz
    prInfo "Downloading $NAME..."
    if ! aria2c -d /tmp "$URL"; then
        prWarn "Failed to download $NAME."
        rm /tmp/"$NAME"
        return 1
    fi

    if [[ -d $INSTALL_DIR ]]; then
        prInfo "Backing up old Clang build..."
        [[ -d $INSTALL_DIR-old ]] && rm -r $INSTALL_DIR-old
        mv -f $INSTALL_DIR{,-old}
    fi

    prInfo "Extracting $NAME..."
    tar -C /opt/kud -xf /tmp/"$NAME"
    mv /opt/kud/"${NAME/.tar.gz/}" $INSTALL_DIR
    # write build version
    echo "$LATEST" >$INSTALL_DIR/ClangVersion.txt
    rm /tmp/"$NAME"

    # {29} = last 28 letters of SHA-1 + trailing right parentheses
    VERSION=$($INSTALL_DIR/bin/clang --version | head -1 | cut -d ' ' -f 1,2,4,6 | sed -e 's/.\{29\}$//')
    prInfo "Successfully installed $VERSION."
}

# Fix Snapdragon LLVM permissions and symlinks; prebuilts extracted from BSP
fixSdllvm() {
    chkArch x86_64 || return 1
    cd "$1" || { prWarn "$BLD$(basename "$1")$RST doesn't exist in defined path" && return 1; }

    # try to get Clang major version
    chmod +x bin/clang
    VERSION=$(bin/clang --version | head -1 | cut -d' ' -f3 | cut -d. -f1)

    prInfo "Fixing permissions and symlinks..."
    (
        cd bin || return 1
        for i in {aarch64,arm}-link; do
            rm -f $i
            ln -s ld.qcld $i
        done
        for i in clang{++,c{l,pp}}; do
            rm -f $i
            ln -s clang $i
        done
        for i in ld{,64}.lld lld-link wasm-ld; do
            rm -f $i
            ln -s lld $i
        done
        for i in llvm-{dlltool,lib,ranlib}; do
            rm -f $i
            ln -s llvm-ar $i
        done
        rm -f clang llvm-strip
        ln -s clang{-"$VERSION",}
        ln -s llvm-{objcopy,strip}
    )
    (
        cd lib || return 1
        for i in LTO LW; do
            rm -f lib$i.so
            ln -s lib$i.so{."$VERSION",}
        done
        rm -f libc++.so.1 libc++abi.so{,.1}
        ln -s libc++.so.1{.0,}
        ln -s libc++abi.so{.1,}
        ln -s libc++abi.so.1{.0,}
    )
    find ./**/bin -type f -exec chmod +x {} \;
    find libexec -type f -exec chmod +x {} \;

    prInfo "Done."
    cd - || true
}

# A wannabe rankmirrors that doesn't expect repository name being exist on URI
# Usage: rankMirrors <repo name> <mirrorlist or stdin>
rankMirrors() {
    local ARCH REPO RESULT URL
    ARCH=$(uname -m)

    # Bail out early if no repo name
    [[ -z $1 ]] && { prWarn "Incorrect usage!" && return 1; }

    # Parse every URL in the mirrorlist
    while read -r URL; do
        # Convert to base repository URL
        REPO_URL=$(echo "$URL" | sed -e "s/\$repo/$1/" -e "s/\$arch/$ARCH/")
        # Track status code and time required to download database
        RESULT=$(curl -s -w '%{time_total} %{http_code}' "$REPO_URL"/"$1".db -o /dev/null)
        # Only save to temporary file if it can be downloaded
        [[ $(echo "$RESULT" | cut -d' ' -f2) -eq 200 ]] && echo "$RESULT $REPO_URL" >>/tmp/"$0"
    done < <(cut -d' ' -f3 "$2" 2>/dev/null)
    [[ ! -f /tmp/$0 ]] && { prWarn "Nothing to rank?" && return 1; }

    # Convert back and rank mirrors by fastest download time
    while read -r URL; do
        echo "Server = $URL"
    done < <(sort -n /tmp/"$0" | sed -e "s/$1/\$repo/" -e "s/$ARCH/\$arch/" | cut -d' ' -f3)
    # Delete temporary file afterwards
    rm /tmp/"$0"
}

# sudo: Update Arch Linux (CN) mirrorlist, sorted by the fastest
updMirrorlist() {
    chkArch x86_64 || { [[ -n $IS_TERMUX ]] && return 1 || exit 1; }

    # Prevent executing on non-Arch
    . /etc/os-release 2>/dev/null
    [[ $ID != arch ]] && {
        prWarn "This function is only available for Arch Linux."
        { [[ -n $IS_TERMUX ]] && return 1 || exit 1; }
    }

    # Arch Linux official repositories can just use reflector
    prInfo "Updating Arch Linux mirrorlist..."
    reflector --save /etc/pacman.d/mirrorlist --sort rate --threads "$(nproc --all)"

    # Chaotic-AUR
    prInfo "Updating Chaotic-AUR mirrorlist..."
    curl -s https://lonewolf.pedrohlc.com/chaotic-aur/mirrorlist |
        sed -e /#/d | rankMirrors chaotic-aur - >/etc/pacman.d/chaotic-mirrorlist

    # Arch Linux CN
    prInfo "Updating Arch Linux CN mirrorlist..."
    curl -s https://raw.githubusercontent.com/archlinuxcn/mirrorlist-repo/master/archlinuxcn-mirrorlist |
        sed -e s/#Server/Server/g -e /##/d |
        rankMirrors archlinuxcn - >/etc/pacman.d/archlinuxcn-mirrorlist

    prInfo "Done."
}

# sudo: Shortcut to do system update; completely depends on distribution
sysUpdate() {
    # Try inheriting Distro's /etc/os-release first
    . /etc/os-release 2>/dev/null
    # If $ID returns empty, check possibility of running Termux on Android
    # This shouldn't interfere with (ch|pr)oot-ed environment
    [[ -z $ID ]] && [[ -n $IS_TERMUX ]] && ID=termux
    case $ID in
    alpine)
        apk update && apk upgrade
        ;;
    arch | manjaro)
        # AUR, please fuck yourself
        [[ -n $(command -v powerpill) ]] && UPD=powerpill || UPD=pacman
        pacman -Sy && $UPD -Su --noconfirm
        ;;
    debian | ubuntu)
        apt update && apt dist-upgrade -y
        ;;
    termux)
        # Equivalent to `apt update && apt upgrade`
        pkg update -y
        ;;
    *) prWarn "This distribution (${ID:-unknown}) is currently not supported." ;;
    esac
}

if [[ -z $IS_TERMUX ]]; then
    # Wrap around sudo
    alias updMirrorlist='chkSudo su -c ". $SCRIPT_DIR/env/global && $(declare -f rankMirrors updMirrorlist) && updMirrorlist"'
    alias sysUpdate='chkSudo su -c ". $SCRIPT_DIR/env/global && $(declare -f sysUpdate) && sysUpdate"'
fi
