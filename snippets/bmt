#!/usr/bin/env bash
# Bare-metal toolchain compilation snippets
# Copyright (C) 2019 Albert I (krasCGQ)
# SPDX-License-Identifier: GPL-3.0-or-later

# Location of working directory
BMT_DIR=${HOME}/build/bmt

# Sync toolchain components
function bmt_sync {(
    # Toolchain components version
    GMP=gmp-6.1.2
    ISL=isl-0.20
    MPC=mpc-1.1.0
    MPFR=mpfr-4.0.2

    # Create working directory if it doesn't exist and switch to it
    [[ ! -d ${BMT_DIR} ]] && mkdir -p "${BMT_DIR}"
    cd "${BMT_DIR}" || { pr_err "Working directory doesn't exist!"; return 1; }

    # Binutils
    pr_info "Syncing Binutils..."
    git -C binutils status &> /dev/null || git clone git://sourceware.org/git/binutils-gdb --depth=1 binutils
    git -C binutils fetch origin master
    git -C binutils reset --hard origin/master

    # GCC
    pr_info "Syncing GCC..."
    git -C gcc status &> /dev/null || git clone git://gcc.gnu.org/git/gcc -b master --depth=1
    git -C gcc fetch origin master
    git -C gcc reset --hard origin/master

    # GMP
    pr_info "Fetching ${GMP}..."
    find . -maxdepth 1 -name gmp-'*' | grep -v ${GMP} | xargs rm -rf
    if [[ ! -d ${GMP} ]]; then
        (
            if [[ ! -f ${GMP}.tar.xz ]]; then
                curl -O https://ftp.gnu.org/gnu/gmp/${GMP}.tar.xz || { pr_err "Error while downloading GMP"; return 1; }
            fi
            tar -xf ${GMP}.tar.xz || { pr_err "Error while extracting GMP"; return 1; }
        ) || { rm -f ${GMP}.tar.xz; return 1; }
    fi

    # ISL
    pr_info "Fetching ${ISL}..."
    find . -maxdepth 1 -name isl-'*' | grep -v ${ISL} | xargs rm -rf
    if [[ ! -d ${ISL} ]]; then
        (
            if [[ ! -f ${ISL}.tar.xz ]]; then
                curl -O http://isl.gforge.inria.fr/${ISL}.tar.xz || { pr_err "Error while downloading ISL"; return 1; }
            fi
            tar -xf ${ISL}.tar.xz || { pr_err "Error while extracting ISL"; return 1; }
        ) || { rm -f ${ISL}.tar.xz; return 1; }
    fi

    # MPC
    pr_info "Fetching ${MPC}..."
    find . -maxdepth 1 -name mpc-'*' | grep -v ${MPC} | xargs rm -rf
    if [[ ! -d ${MPC} ]]; then
        (
            if [[ ! -f ${MPC}.tar.gz ]]; then
                curl -O https://ftp.gnu.org/gnu/mpc/${MPC}.tar.gz || { pr_err "Error while downloading MPC"; return 1; }
            fi
            tar -xf ${MPC}.tar.gz || { pr_err "Error while extracting MPC"; return 1; }
        ) || { rm -f ${MPC}.tar.gz; return 1; }
    fi

    # MPFR
    pr_info "Fetching ${MPFR}..."
    find . -maxdepth 1 -name mpfr-'*' | grep -v ${MPFR} | xargs rm -rf
    if [[ ! -d ${MPFR} ]]; then
        (
            if [[ ! -f ${MPFR}.tar.xz ]]; then
                curl -O https://ftp.gnu.org/gnu/mpfr/${MPFR}.tar.xz || { pr_err "Error while downloading MPFR"; return 1; }
            fi
            tar -xf ${MPFR}.tar.xz || { pr_err "Error while extracting MPFR"; return 1; }
        ) || { rm -f ${MPFR}.tar.xz; return 1; }
    fi

    # Symlinks
    pr_info "Updating symlinks..."
    ln -sf "${BMT_DIR}"/${GMP} gcc/gmp
    ln -sf "${BMT_DIR}"/${ISL} gcc/isl
    ln -sf "${BMT_DIR}"/${MPC} gcc/mpc
    ln -sf "${BMT_DIR}"/${MPFR} gcc/mpfr

    # Function ending
    pr_info "Done"
    unset ISL MPC MPFR
) || { unset ISL MPC MPFR; return 1; } }

# Build bare metal toolchain
function bmt_build {
    # Target ARCH we're going to build
    # Only supports ARM, AArch64 (ARM64), x86_64
    case ${1} in
        aarch64|x86_64) # ${1}-elf
            TARGET=${1}-elf ;;
        arm) # arm-eabi
            TARGET=arm-eabi ;;
        arm64) # AArch64 - aarch64-elf
            TARGET=aarch64-elf ;;
        *)
            pr_err "Unsupported ARCH specified!"
            return 1 ;;
    esac

    # Common configuration flags
    COMMON_FLAGS=( "CFLAGS=-g0 -O2 -fstack-protector-strong"
                   "CXXFLAGS=-g0 -O2 -fstack-protector-strong"
                   "--target=${TARGET}" "--prefix=${BMT_DIR}/${TARGET}"
                   "--disable-multilib" "--disable-werror" )

    # Save current PATH as OLD_PATH
    OLD_PATH=${PATH}

    # Set toolchain directory to PATH
    export PATH=${BMT_DIR}/${TARGET}/bin:${PATH}

    (
        cd "${BMT_DIR}" || { pr_err "Working directory doesn't exist!"; return 1; }

        # Re-create build folders
        pr_info "Cleaning working directory..."
        find . -maxdepth 1 -name build-'*' -exec rm -rf {} \;
        mkdir -p build-{binutils,gcc}

        # If target toolchain exists, remove it
        [[ -d ${TARGET} ]] && rm -rf ${TARGET}

        ( # Build Binutils
            cd build-binutils || { pr_err "Binutils build folder doesn't exist!"; return 1; }

            pr_info "Configuring Binutils..."
            ./../binutils/configure "${COMMON_FLAGS[@]}" \
                                    --disable-gdb \
                                    --enable-gold \
                || { pr_err "Error while configuring Binutils"; return 1; }

            pr_info "Building Binutils..."
            make -j"${THREADS}" || { pr_err "Error while building Binutils"; return 1; }

            pr_info "Installing Binutils..."
            make install -j"${THREADS}" || { pr_err "Error while installing Binutils"; return 1; }
        ) || return 1

        ( # Build GCC
            cd build-gcc || { pr_err "GCC build folder doesn't exist!"; return 1; }

            pr_info "Configuring GCC..."
            ./../gcc/configure "${COMMON_FLAGS[@]}" \
                               --enable-languages=c \
                               --without-headers \
                || { pr_err "Error while configuring GCC"; return 1; }

            pr_info "Building GCC..."
            make all-gcc -j"${THREADS}" || { pr_err "Error while building GCC"; return 1; }

            pr_info "Installing GCC..."
            make install-gcc -j"${THREADS}" || { pr_err "Error while installing GCC"; return 1; }

            pr_info "Building libgcc for target..."
            make all-target-libgcc -j"${THREADS}" || { pr_err "Error while building libgcc for target"; return 1; }

            pr_info "Installing libgcc for target..."
            make install-target-libgcc -j"${THREADS}" || { pr_err "Error while installing libgcc for target"; return 1; }
        ) || return 1
    ) || { export PATH=${OLD_PATH}; unset COMMON_FLAGS OLD_PATH; return 1; }

    pr_info "Successfully built toolchain with the following details:" \
            "Version     : $("${TARGET}"-gcc --version | head -1)" \
            "Install Path: $(command -v "${TARGET}"-gcc)"

    # Revert PATH back to its original state
    export PATH=${OLD_PATH}

    # Cleanup
    unset COMMON_FLAGS OLD_PATH
}
